"""
PROJECT HYPERION - PHASE 7: FORENSICS API ROUTER
=================================================

FastAPI router for Gemini Forensic Reporting endpoints
Integrates with existing Phase 6 backend without breaking changes
"""

from fastapi import APIRouter, HTTPException
from fastapi.responses import StreamingResponse
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any
import logging

from app.services.gemini_reporter import get_gemini_reporter, stream_forensic_report

logger = logging.getLogger(__name__)

# Create router
router = APIRouter()


# ============================================================================
# PYDANTIC MODELS (Request/Response schemas)
# ============================================================================

class OraclePayload(BaseModel):
    """
    Oracle data structure from Phase 6 Arbiter
    Matches the signed payload from weather/IoT oracles
    """
    policy_id: str = Field(..., description="CIP-68 Policy NFT ID")
    location_id: str = Field(..., description="Geographic location identifier")
    wind_speed: float = Field(..., description="Wind speed in m/s")
    measurement_time: int = Field(..., description="Unix timestamp of measurement")
    threshold: float = Field(default=40.0, description="Trigger threshold in m/s")
    nonce: int = Field(default=0, description="Replay protection nonce")
    signature: Optional[str] = Field(default=None, description="Ed25519 signature (hex)")

    class Config:
        json_schema_extra = {
            "example": {
                "policy_id": "d5e6e2e1a6e1e9e8e7e6e5e4e3e2e1e0",
                "location_id": "miami_beach_buoy_12",
                "wind_speed": 45.5,
                "measurement_time": 1699564800,
                "threshold": 40.0,
                "nonce": 42,
                "signature": "a1b2c3d4..."
            }
        }


class PolicyMetadata(BaseModel):
    """
    Optional CIP-68 metadata from Phase 1 Policy NFT
    """
    coverage_type: str = Field(default="Hurricane Wind Damage")
    beneficiary: str = Field(..., description="Wallet address or pubkey hash")
    coverage_amount: int = Field(..., description="Payout amount in smallest unit (micro-USDM)")


class ForensicReportRequest(BaseModel):
    """
    Request body for forensic report generation
    """
    oracle_payload: OraclePayload
    policy_metadata: Optional[PolicyMetadata] = None


class ForensicReportResponse(BaseModel):
    """
    Response for static report generation
    """
    success: bool
    policy_id: str
    report: str
    timestamp: int


# ============================================================================
# ENDPOINTS
# ============================================================================

@router.post("/stream")
async def stream_forensic_report_endpoint(request: ForensicReportRequest):
    """
    Stream a forensic report using Google Gemini AI

    This endpoint:
    1. Accepts oracle payload (from Phase 6 Arbiter)
    2. Optionally accepts policy metadata (from Phase 1 NFT)
    3. Streams a human-readable forensic explanation via SSE
    4. Returns text chunks as they're generated by Gemini

    **Integration:**
    - Frontend: Use EventSource or fetch with streaming
    - Phase 6: Pass Arbiter's signed oracle data
    - Phase 1: Optionally include CIP-68 metadata for context

    **Returns:** text/event-stream with chunks of the forensic report
    """
    try:
        logger.info(f"Forensic report streaming requested for policy: {request.oracle_payload.policy_id}")

        # Prepare data for gemini_reporter
        data = {
            "oracle_payload": request.oracle_payload.model_dump(),
        }

        if request.policy_metadata:
            data["policy_metadata"] = request.policy_metadata.model_dump()

        # Stream response using Server-Sent Events (SSE)
        async def event_generator():
            """Generate SSE-formatted events"""
            try:
                async for chunk in stream_forensic_report(data):
                    # SSE format: data: <content>\n\n
                    yield f"data: {chunk}\n\n"

                # Send completion signal
                yield "data: [DONE]\n\n"

            except Exception as e:
                logger.error(f"Streaming error: {str(e)}")
                yield f"data: [ERROR] {str(e)}\n\n"

        return StreamingResponse(
            event_generator(),
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "X-Accel-Buffering": "no",  # Disable nginx buffering
            }
        )

    except ValueError as e:
        logger.error(f"Validation error: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))

    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")


@router.post("/generate", response_model=ForensicReportResponse)
async def generate_static_report(request: ForensicReportRequest):
    """
    Generate a complete (non-streaming) forensic report

    Useful for:
    - PDF export
    - Email notifications
    - Archival/audit logs

    **Returns:** JSON with full report text
    """
    try:
        logger.info(f"Static report requested for policy: {request.oracle_payload.policy_id}")

        # Prepare data
        data = {
            "oracle_payload": request.oracle_payload.model_dump(),
        }

        if request.policy_metadata:
            data["policy_metadata"] = request.policy_metadata.model_dump()

        # Collect all chunks into one string
        reporter = get_gemini_reporter()
        report_text = await reporter.generate_static_report(
            oracle_payload=data["oracle_payload"],
            policy_metadata=data.get("policy_metadata")
        )

        return ForensicReportResponse(
            success=True,
            policy_id=request.oracle_payload.policy_id,
            report=report_text,
            timestamp=request.oracle_payload.measurement_time
        )

    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

    except Exception as e:
        logger.error(f"Report generation failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/health")
async def forensics_health_check():
    """
    Health check for forensic reporting service
    Tests Gemini API connection
    """
    try:
        reporter = get_gemini_reporter()
        return {
            "status": "healthy",
            "service": "Gemini Forensic Reporter",
            "model": "gemini-1.5-flash",
            "api_connected": True
        }
    except Exception as e:
        logger.error(f"Health check failed: {str(e)}")
        return {
            "status": "unhealthy",
            "service": "Gemini Forensic Reporter",
            "error": str(e),
            "api_connected": False
        }
